% DC1532 / LTC2268 Interface Example
% LTC2268: 14-Bit, 125Msps Low Power Dual ADCs
%
% This program demonstrates how to communicate with the LTC2268 demo board 
% using Matlab. Examples are provided for reading data captured by the ADC, 
% or test data generated by the ADC.
% 
% Board setup is described in Demo Manual 1532. Follow the procedure in 
% this manual, and verify operation with the PScope software. Once 
% operation is verified, exit PScope and run this script.
% 
% Demo board documentation:
% http://www.linear.com/demo/1532
% http://www.linear.com/product/LTC2268#demoboards
% 
% LTC2268 product page
% http://www.linear.com/product/LTC2268
% 
% Copyright (c) 2015, Linear Technology Corp.(LTC)
% All rights reserved.
% 
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
% 
% 1. Redistributions of source code must retain the above copyright notice, 
%    this list of conditions and the following disclaimer.
% 2. Redistributions in binary form must reproduce the above copyright notice,
%    this list of conditions and the following disclaimer in the documentation
%    and/or other materials provided with the distribution.
% 
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
% ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
% WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
% DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
% ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
% (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
% LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
% ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
% (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
% SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
% 
% The views and conclusions contained in the software and documentation are those
% of the authors and should not be interpreted as representing official policies,
% either expressed or implied, of Linear Technology Corp.

% NOTE:
% 	ADD THE ABSOLUTE PATH TO "linear_lab_tools\matlab" FOLDER BEFORE RUNNING THE SCRIPT.
%   RUN "mex -setup" TO SET UP COMPILER AND CHOSE THE OPTION "Lcc-win32 C".

function Ltc2268Dc1532(arg1NumSamples, arg2Verbose, doDemo)
    
    if(~nargin)
        numAdcSamples = 64 * 1024;
        % Print extra information to console
        verbose = true;
        % Plot data to screen
        plotData = true;
        % Write data out to a text file
        writeToFile = true;
    else
        numAdcSamples = arg1NumSamples;
        verbose = arg2Verbose;
        plotData = doDemo;
        writeToFile = doDemo;
    end
    
    % LTC2268 Serial Programming Mode Registers
    RESET_REG = 0;
    POWER_DOWN_REG = 1;
    OUTPUT_MODE_REG = 2;
    TEST_PATTERN_MSB_REG = 3;
    TEST_PATTERN_LSB_REG = 4;

    % Change this to collect real or test pattern data
    useTestData = false;
    % Change this to set the output when using the test pattern
    testDataValue = 10922;              % 14-bit data

    TOTAL_ADC_SAMPLES = 2 * numAdcSamples; % Two channel part
    SAMPLE_BYTES = 2;
    
    % Returns the object in the class constructor
    comm = LtcControllerComm();  
    
    % find demo board with correct ID
    EEPROM_ID = '[0074 DEMO 10 DC1532A-A LTC2268-14 D2175]';
    eepromIdSize = length(EEPROM_ID);
    fprintf('Looking for a DC1371 with a DC1532A-A demoboard\n');
    
    deviceInfoList = comm.ListControllers(comm.TYPE_DC1371, 1);
	
	% Open communication to the device
    cId = comm.Init(deviceInfoList);
    
    for info = deviceInfoList
        % if strcmp(EEPROM_ID(1 : eepromIdSize - 1), comm.EepromReadString(cId, eepromIdSize))
		if ~isempty(strfind(comm.EepromReadString(cId, eepromIdSize), 'DC1532'))
            break;
        end
        cId = comm.Cleanup(cId);
    end
    
    if(cId == 0)
        fprintf('Device not found\n');
    else
        fprintf('Device Found\n');
    end
        
    if (verbose)
        fprintf('Configuring SPI registers\n');
    end
    
    if (useTestData == true)
        fprintf('Set to read real data\n');
    else
        fprintf('Set to generate test data\n');
    end

    if (useTestData)
        reg3 = int32(testDataValue);
        reg3 = int32(bitshift(testDataValue, -8));
        reg3 = bitor(bitand(reg3, 63), 128);
        reg4 = bitand(testDataValue, 255);
    else
        reg3 = 0;
        reg4 = 0;
    end
    
    % Software Reset
    comm.SpiSendByteAtAddress(cId, RESET_REG, 128); 
    % Enable Clock DCS, Disable Output Randomizer, Enable Binary Data Format
    comm.SpiSendByteAtAddress(cId, POWER_DOWN_REG, 0);  
    % Disable LVDS Internal Terminaion, Enable Digital Outputs, 2 Lanes, 16 - Bit
    comm.SpiSendByteAtAddress(cId, OUTPUT_MODE_REG, 0);
    % Enable Digital Output Teast Pattern, Bits D5:D0 holds TP13:TP8
    comm.SpiSendByteAtAddress(cId, TEST_PATTERN_MSB_REG, reg3);
    % Bits D7:D0 holds TP7:TP0
    comm.SpiSendByteAtAddress(cId, TEST_PATTERN_LSB_REG, reg4);
    
    if (comm.FpgaGetIsLoaded(cId, 'S2175'))
       if(verbose)
            fprintf('Loading FPGA\n');
       end 
       comm.FpgaLoadFile(cId, 'S2175');
    else
       if(verbose)
            fprintf('FPGA already loaded\n');
       end 
    end
    
    % demo-board specific information needed by the DC1371 (0x28000000)
    comm.DC1371SetDemoConfig(cId, 671088640)

    if(verbose)
        fprintf('Starting Data Collect\n');
    end 
    
    comm.DataStartCollect(cId, TOTAL_ADC_SAMPLES, comm.TRIGGER_NONE);
    
    for i = 1: 10
        isDone = comm.DataIsCollectDone(cId);
        if(isDone)
            break;
        end
        pause(0.2);
    end
    
    if(isDone ~= true)
        error('LtcControllerComm:HardwareError', ...
            'Data collect timed out (missing clock?)');
    end
    
    if(verbose)
        fprintf('Data Collect done\n');
    end
    
    if(verbose)
        fprintf('Reading data\n');
    end
    
    [data, numBytes] = comm.DataReceiveUint16Values(cId, TOTAL_ADC_SAMPLES);
    
    if(useTestData)
        if (nnz(data == 10922) == length(data))
            fprintf('Good data!!\n');
        else
            fprintf('Bad data!!\n');
        end
    end
    
    if(verbose)
        fprintf('Data Read done\n');
    end
    
    % Split data into two channels
    dataCh1 = zeros(1, TOTAL_ADC_SAMPLES/2);
    dataCh2 = zeros(1, TOTAL_ADC_SAMPLES/2);
    
    dataCh1(1 : TOTAL_ADC_SAMPLES/2) = data(1 : 2 : TOTAL_ADC_SAMPLES);
    dataCh2(1 : TOTAL_ADC_SAMPLES/2) = data(2 : 2 : TOTAL_ADC_SAMPLES);
    
    if(writeToFile)
        if(verbose)
            fprintf('Writing data to file\n');
        end    

        fileID = fopen('data.txt','w');

        for i = 1:numAdcSamples
            fprintf(fileID,'%d\t%d\r\n', dataCh1(i), dataCh2(i));
        end

        fclose(fileID);
        fprintf('File write done\n');
    end
    
    if(plotData == true)
        figure(1)
        subplot(2, 1, 1)
        plot(dataCh1)
        title('CH0')
        subplot(2, 1, 2)
        plot(dataCh2)
        title('CH1')

        adcAmplitude = 65536.0 / 2.0;

        windowScale = (numAdcSamples/2) / sum(blackman(numAdcSamples/2));
        fprintf('Window scaling factor: %d\n', windowScale);

        windowedDataCh1 = dataCh1' .* blackman(numAdcSamples);
        windowedDataCh1 = windowedDataCh1 .* windowScale; 	% Apply Blackman window
        freqDomainCh1 = fft(windowedDataCh1)/(numAdcSamples); % FFT
        freqDomainMagnitudeCh1 = abs(freqDomainCh1); 		% Extract magnitude
        freqDomainMagnitudeDbCh1 = 10 * log10(freqDomainMagnitudeCh1/adcAmplitude);
        
        windowedDataCh2 = dataCh2' .* blackman(numAdcSamples);
        windowedDataCh2 = windowedDataCh2 .* windowScale; 	% Apply Blackman window
        freqDomainCh2 = fft(windowedDataCh2)/(numAdcSamples); % FFT
        freqDomainMagnitudeCh2 = abs(freqDomainCh2); 		% Extract magnitude
        freqDomainMagnitudeDbCh2 = 10 * log10(freqDomainMagnitudeCh2/adcAmplitude);
        
        figure(2)
        subplot(2, 1, 1)
        plot(freqDomainMagnitudeDbCh1)
        title('CH0 FFT')
        subplot(2, 1, 2)
        plot(freqDomainMagnitudeDbCh2)
        title('CH1 FFT')
        
    end
    fprintf('All finished\n');
    
    
    
end
