% DC1975 / LTC2270 Interface Example
% LTC2270: 16-Bit, 20Msps Low Noise Dual ADC
%
% This program demonstrates how to communicate with the LTC2270 demo board 
% using Matlab. Examples are provided for reading data captured by the ADC, 
% or test data generated by the ADC.
% 
% Board setup is described in Demo Manual 1975. Follow the procedure in 
% this manual, and verify operation with the PScope software. Once 
% operation is verified, exit PScope and run this script.
% 
% Demo board documentation:
% http://www.linear.com/demo/1975
% http://www.linear.com/product/LTC2270#demoboards
% 
% LTC2270 product page
% http://www.linear.com/product/LTC2270
%  
% REVISION HISTORY
% $Revision: 6108 $
% $Date: 2016-11-30 10:34:36 -0800 (Wed, 30 Nov 2016) $
%
% Copyright (c) 2015, Linear Technology Corp.(LTC)
% All rights reserved.
% 
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
% 
% 1. Redistributions of source code must retain the above copyright notice, 
%    this list of conditions and the following disclaimer.
% 2. Redistributions in binary form must reproduce the above copyright notice,
%    this list of conditions and the following disclaimer in the documentation
%    and/or other materials provided with the distribution.
% 
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
% ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
% WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
% DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
% ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
% (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
% LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
% ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
% (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
% SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
% 
% The views and conclusions contained in the software and documentation are those
% of the authors and should not be interpreted as representing official policies,
% either expressed or implied, of Linear Technology Corp.

% NOTE:
% 	ADD THE ABSOLUTE PATH TO "linear_lab_tools\matlab" FOLDER BEFORE RUNNING THE SCRIPT.
%   RUN "mex -setup" TO SET UP COMPILER AND CHOSE THE OPTION "Lcc-win32 C".

function ltc2270_dc1975(num_samples, is_verbose, do_plot, do_write_to_file)
        
if ~exist('num_samples', 'var'); num_samples = 32 * 1024; end

do_demo = false;
if nargout == 0
    do_demo = true;
end
if ~exist('is_verbose', 'var'); is_verbose = do_demo; end
if ~exist('do_plot', 'var'); do_plot = do_demo; end
if ~exist('do_write_to_file', 'var'); do_write_to_file = do_demo; end

% set testDataReg to one of these constants
DATA_REAL = 0;
DATA_ALL_ZEROS = 8;
DATA_ALL_ONES = 24;
DATA_CHECKERBOARD = 40;
DATA_ALTERNATING = 56;
% testDataReg = DATA_ALTERNATING
test_data_reg = DATA_REAL;

NUM_ADC_SAMPLES_PER_CH = num_samples / 2;
SAMPLE_BYTES = 2;

% Returns the object in the class constructor
comm = llt.common.LtcControllerComm();  

device_info_list = comm.list_controllers(comm.TYPE_DC890);

% Open communication to the device
cid = comm.init(device_info_list);

% find demo board with correct ID
EEPROM_ID = 'LTC2270,D9002,DC1975A-A,YGG200T,CMOS,----';
eeprom_id_size = length(EEPROM_ID);
fprintf('\nLooking for a DC890 with a DC1975A-A demoboard');

for info = device_info_list
    % if strcmp(EEPROM_ID, comm.EepromReadString(cId, eepromIdSize))
    if(~isempty(strfind(comm.eeprom_read_string(cid, eeprom_id_size), 'DC1975')))
        break;
    end

    cid = comm.cleanup(cid);
end

if(cid == 0)
    fprintf('\nDevice not found');
else
    fprintf('\nDevice Found');
end

comm.dc890_gpio_set_byte(cid, 248);
comm.dc890_gpio_spi_set_bits(cid, 3, 0, 1);

if (is_verbose)
    fprintf('Configuring SPI registers');
end

if (test_data_reg == DATA_REAL)
    fprintf('\nSet to read real data');
else
    fprintf('\nSet to generate test data');
end

comm.spi_send_byte_at_address(cid, 0, 128);
comm.spi_send_byte_at_address(cid, 1, 0);
comm.spi_send_byte_at_address(cid, 2, 0);
comm.spi_send_byte_at_address(cid, 3, 112);
comm.spi_send_byte_at_address(cid, 4, test_data_reg);

if (~comm.fpga_get_is_loaded(cid, 'CMOS'))
   if(is_verbose)
        fprintf('\nLoading FPGA');
   end 
   comm.fpga_load_file(cid, 'CMOS');
else
   if(is_verbose)
        fprintf('\nFPGA already loaded');
   end 
end

if(is_verbose)
    fprintf('\nStarting Data Collect');
end 

comm.data_set_high_byte_first(cid);

comm.data_set_characteristics(cid, true, SAMPLE_BYTES, true);
comm.data_start_collect(cid, num_samples, comm.TRIGGER_NONE);

for i = 1: 10
    if comm.data_is_collect_done(cid);
        break;
    end
    pause(0.2);
end
if(is_done ~= true)
    error('LtcControllerComm:HardwareError', 'Data collect timed out (missing clock?)');
end

if(is_verbose)
    fprintf('\nData Collect done');
end

comm.dc890_flush(cid);

if(is_verbose)
    fprintf('\nReading data');
end

data = comm.data_receive_uint16_values(cid, num_samples);

if(is_verbose)
    fprintf('\nData Read done');
end

% Split data into two channels
data_ch1 = zeros(1, NUM_ADC_SAMPLES_PER_CH);
data_ch2 = zeros(1, NUM_ADC_SAMPLES_PER_CH);

for i = 1 : NUM_ADC_SAMPLES_PER_CH
    data_ch1(i) = bitand(data(2*i - 1), 65535);
    data_ch2(i) = bitand(data(2*i), 65535);
end

if(do_write_to_file)
    if(is_verbose)
        fprintf('\nWriting data to file');
    end    

    file_id = fopen('data.txt','w');

    for i = 1:NUM_ADC_SAMPLES_PER_CH
        if(mod(i, 2) == 0)
            fprintf(file_id,'%d\t%d\r\n', data_ch1(i), data_ch2(i));
        end
    end

    fclose(file_id);
    fprintf('\nFile write done');
end

% Plot data if not running pattern check
if(do_plot == true)
    figure(1)
    subplot(2, 1, 1)
    plot(data_ch1)
    title('CH0')
    subplot(2, 1, 2)
    plot(data_ch2)
    title('CH1')

    adc_amplitude = 65536.0 / 2.0;

    window_scale = (num_samples/2) / sum(llt.common.fft_window(num_samples/2));
    fprintf('\nWindow scaling factor: %d', window_scale);

    data_ch1 = data_ch1 - mean(data_ch1);                  % Normalizing to remove DC
    windowed_data_ch1 = data_ch1' .* llt.common.fft_window(num_samples/2);
    windowed_data_ch1 = windowed_data_ch1 .* window_scale; 	% Apply BlackmanHarris92 window
    freq_domain_ch1 = fft(windowed_data_ch1)/(NUM_ADC_SAMPLES_PER_CH); % FFT
    freq_domain_magnitude_ch1 = abs(freq_domain_ch1); 		% Extract magnitude
    freq_domain_magnitude_db_ch1 = 20 * log10(freq_domain_magnitude_ch1/adc_amplitude);

    data_ch2 = data_ch2 - mean(data_ch2);                  % Normalizing to remove DC
    windowed_data_ch2 = data_ch2' .* llt.common.fft_window(num_samples/2);
    windowed_data_ch2 = windowed_data_ch2 .* window_scale; 	% Apply BlackmanHarris92 window
    freq_domain_ch2 = fft(windowed_data_ch2)/(NUM_ADC_SAMPLES_PER_CH); % FFT
    freq_domain_magnitude_ch2 = abs(freq_domain_ch2); 		% Extract magnitude
    freq_domain_magnitude_db_ch2 = 20 * log10(freq_domain_magnitude_ch2/adc_amplitude);

    figure(2)
    subplot(2, 1, 1)
    plot(freq_domain_magnitude_db_ch1)
    title('CH0 FFT')
    subplot(2, 1, 2)
    plot(freq_domain_magnitude_db_ch2)
    title('CH1 FFT')

end
fprintf('\nAll finished');
    
end